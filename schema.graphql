schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type Account @aws_api_key {
  activeAccount: Boolean
  actualOrders: Int
  configuration: [CConfigurations]
  createdAt: AWSDateTime!
  id: ID!
  isVtexAccount: Boolean
  maxiumMonthlyOrders: Int
  name: String!
  salesChannels(filter: ModelSalesChannelFilterInput, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelSalesChannelConnection
  updatedAt: AWSDateTime!
}

type AssignmentTime @aws_api_key {
  assignedAt: String
}

type AvailablePackages @aws_api_key {
  description: String
  id: String!
  name: String!
  price: String!
  quantity: Int!
  type: String!
}

type Batch @aws_api_key {
  assignmentMethod: String
  assignmentTime: AssignmentTime
  createdAt: AWSDateTime!
  deliveryWindow: DeliveryWindowBatch
  id: ID!
  orders(filter: ModelOrderFilterInput, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelOrderConnection
  seller: String
  status: String
  updatedAt: AWSDateTime!
  worksheets(filter: ModelWorksheetFilterInput, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelWorksheetConnection
}

type Billing @aws_api_key @aws_cognito_user_pools {
  address1: String
  address2: String
  billingName: String
  city: String
  country: String
  discount: Float
  docType: DocType
  freighAmount: Float
  id: String
  state: String
  tax: Float
  total: Float
}

type CConfigurations @aws_api_key @aws_cognito_user_pools {
  key: String
}

type CLocation @aws_api_key @aws_cognito_user_pools {
  latitude: Float
  longitude: Float
}

type CTimezone @aws_api_key @aws_cognito_user_pools {
  offset: Float!
  value: String!
}

type Carrier @aws_api_key @aws_cognito_user_pools {
  active: Boolean!
  agencyId: String!
  allocationTime: Int
  authorized: Boolean!
  cancelable: Boolean!
  countries: [String!]!
  createdAt: AWSDateTime!
  formConfiguration: [CarrierFormConfigurationField!]!
  hasDevEnvironment: Boolean!
  id: ID!
  integration: CarrierIntegration!
  logo: String
  name: String!
  onHoldServices: Boolean!
  pricing: CarrierPricing
  shippingPaymentMethods: [CarrierShippingPaymentMethod]
  type: [CarrierType!]!
  updatedAt: AWSDateTime!
  withQueues: Boolean
}

type CarrierFormConfigurationAuth @aws_api_key @aws_cognito_user_pools {
  key: String!
  type: CarrierFormConfigurationAuthType!
  value: String!
}

type CarrierFormConfigurationField @aws_api_key @aws_cognito_user_pools {
  description: String
  key: String!
  label: String!
  max: String
  min: String
  options: [CarrierFormConfigurationFieldOption]
  priority: Int
  required: Boolean!
  type: CarrierFormConfigurationFieldType!
  value: String
}

type CarrierFormConfigurationFieldOption @aws_api_key @aws_cognito_user_pools {
  id: String!
  label: String!
  value: String!
}

type CarrierIntegration @aws_api_key @aws_cognito_user_pools {
  dev: CarrierIntegrationEndpoints
  prod: CarrierIntegrationEndpoints
}

type CarrierIntegrationEndpoint @aws_api_key @aws_cognito_user_pools {
  method: CarrierIntegrationMethod!
  protocol: CarrierIntegrationProtocol!
  url: String!
  variables: [CarrierFormConfigurationAuth]
}

type CarrierIntegrationEndpoints @aws_api_key @aws_cognito_user_pools {
  cancelEndpoint: CarrierIntegrationEndpoint
  endpoint: CarrierIntegrationEndpoint!
  pauseEndpoint: CarrierIntegrationEndpoint
  webhookEndpoint: String
}

type CarrierPricing @aws_api_key @aws_cognito_user_pools {
  type: CarrierPricingType
  value: Float
}

type CarrierStoreConfigSettings @aws_api_key @aws_cognito_user_pools {
  key: String!
  label: String
  value: String
}

type CarriersStoreConfig @aws_api_key @aws_cognito_user_pools {
  account: String!
  active: Boolean!
  carrierId: ID!
  config: [CarrierStoreConfigSettings]
  createdAt: AWSDateTime!
  deliveryMethod: [DeliveryMethod]
  env: CEnvironment!
  id: ID!
  name: String
  updatedAt: AWSDateTime!
}

type ContactInformation @aws_api_key {
  email: String
  name: String
  phone: String
}

type Currrency @aws_api_key @aws_cognito_user_pools {
  code: String
  decimalSeparator: String
  deicmalDigits: Int
  groupSeparator: String
  groupSize: Int
  name: String
  symbol: String
}

type Customer @aws_api_key @aws_cognito_user_pools {
  document: String
  documentType: String
  email: String
  firstName: String
  lastName: String
  level: String
  phone: String
  profileId: String
}

type DeliveryMethod @aws_api_key @aws_cognito_user_pools {
  id: String
  name: String
  serviceType: CarrierType!
}

type DeliveryWindow @aws_api_key {
  finalHour: String
  initialHour: String
  name: String
  weekDay: Int
}

type DeliveryWindowBatch @aws_api_key {
  finalHour: String
  initialHour: String
}

type Dimensions @aws_api_key @aws_cognito_user_pools {
  cubicWeight: Float
  height: Float
  lenght: Float
  weight: Float
  width: Float
}

type GeneralConfig @aws_api_key {
  address: String
  addressComplement: String
  changePricesReasons: [Reason]
  city: String
  contactInformation: ContactInformation
  country: String
  deliveryWindow: [DeliveryWindow]
  location: StoreLocation
  measurementUnit: String
  name: String
  replacementReasons: [Reason]
  state: String
}

type InventoryData @aws_api_key @aws_cognito_user_pools {
  quantity: Float
  warehouseId: String
  warehouseName: String
}

type Invoice @aws_api_key @aws_cognito_user_pools {
  invoiceCreationDate: String
  invoiceKey: String
  invoiceNumber: String
  invoiceReceiptDate: String
  invoiceSubtotal: Float
  invoiceTaxes: Float
  invoiceTotal: Float
  invoiceUrl: String
  packages: [String]
}

type Item @aws_api_key @aws_cognito_user_pools {
  EAN: String
  additionalEAN: [String]
  additionalReferenceCode: [String]
  additionalSku: [String]
  basePrice: Float
  brand: Taxonomy
  categories: [Taxonomy]
  description: String
  dimensions: Dimensions
  id: String
  images: [String]
  inventoryData: InventoryData
  isCombo: Boolean
  isTaxable: Boolean
  itemName: String
  label: String
  metaData: AWSJSON
  notes: [String]
  observations: [String]
  pickingOptions: ItemPickingOptions
  price: Float
  qrCodeContent: String
  quantity: Float
  referenceCode: String
  sku: String
  storeConfig: String
  tax: Float
  temperature: Temperature
  unitMultiplier: Float
  unitOfMeasure: UnitOfMeasure
  weightableProduct: Boolean
}

type ItemAssignment @aws_api_key {
  AssignedAt: AWSDateTime
  FinishedAt: AWSDateTime
  StartPickingAt: AWSDateTime
}

type ItemPickingOptions @aws_api_key @aws_cognito_user_pools {
  alternateOptions: [String]
  onNotFound: NotFoundOptions
}

type ItemsByWorksheet @aws_api_key {
  ID: String
  categoriesId: String
  finalPrice: Float
  itemAssignment: ItemAssignment
  name: String
  orderSource: [OrderSource]
  originalPrice: Float
  status: ItemsByWorksheetStatus
  temperature: String
  totalQuantity: Int
}

type Location @aws_api_key @aws_cognito_user_pools {
  alt: Float
  lat: Float
  lng: Float
}

type MarketingData @aws_api_key @aws_cognito_user_pools {
  id: String
  marketingTags: [String]
  utmCampaign: String
  utmMedium: String
  utmPartner: String
  utmSource: String
  utmiPart: String
  utmipage: String
}

type ModelAccountConnection @aws_api_key {
  items: [Account]!
  nextToken: String
}

type ModelBatchConnection @aws_api_key {
  items: [Batch]!
  nextToken: String
}

type ModelCarrierConnection @aws_api_key @aws_cognito_user_pools {
  items: [Carrier]!
  nextToken: String
}

type ModelCarriersStoreConfigConnection @aws_api_key @aws_cognito_user_pools {
  items: [CarriersStoreConfig]!
  nextToken: String
}

type ModelOrderConnection @aws_api_key @aws_cognito_user_pools {
  items: [Order]!
  nextToken: String
}

type ModelSalesChannelConnection @aws_api_key {
  items: [SalesChannel]!
  nextToken: String
}

type ModelSalesSourceConnection @aws_api_key @aws_cognito_user_pools {
  items: [SalesSource]!
  nextToken: String
}

type ModelServiceConnection @aws_api_key @aws_cognito_user_pools {
  items: [Service]!
  nextToken: String
}

type ModelStoreConfigConnection @aws_api_key {
  items: [StoreConfig]!
  nextToken: String
}

type ModelTrackingTimelineConnection @aws_api_key @aws_cognito_user_pools {
  items: [TrackingTimeline]!
  nextToken: String
}

type ModelWorksheetConnection @aws_api_key {
  items: [Worksheet]!
  nextToken: String
}

type Mutation {
  createAccount(condition: ModelAccountConditionInput, input: CreateAccountInput!): Account @aws_api_key
  createBatch(condition: ModelBatchConditionInput, input: CreateBatchInput!): Batch @aws_api_key
  createCarrier(condition: ModelCarrierConditionInput, input: CreateCarrierInput!): Carrier @aws_api_key @aws_cognito_user_pools
  createCarriersStoreConfig(condition: ModelCarriersStoreConfigConditionInput, input: CreateCarriersStoreConfigInput!): CarriersStoreConfig @aws_api_key @aws_cognito_user_pools
  createOrder(condition: ModelOrderConditionInput, input: CreateOrderInput!): Order @aws_api_key @aws_cognito_user_pools
  createSalesChannel(condition: ModelSalesChannelConditionInput, input: CreateSalesChannelInput!): SalesChannel @aws_api_key
  createSalesSource(condition: ModelSalesSourceConditionInput, input: CreateSalesSourceInput!): SalesSource @aws_api_key
  createService(condition: ModelServiceConditionInput, input: CreateServiceInput!): Service @aws_api_key @aws_cognito_user_pools
  createStoreConfig(condition: ModelStoreConfigConditionInput, input: CreateStoreConfigInput!): StoreConfig @aws_api_key
  createTrackingTimeline(condition: ModelTrackingTimelineConditionInput, input: CreateTrackingTimelineInput!): TrackingTimeline @aws_api_key @aws_cognito_user_pools
  createWorksheet(condition: ModelWorksheetConditionInput, input: CreateWorksheetInput!): Worksheet @aws_api_key
  deleteAccount(condition: ModelAccountConditionInput, input: DeleteAccountInput!): Account @aws_api_key
  deleteBatch(condition: ModelBatchConditionInput, input: DeleteBatchInput!): Batch @aws_api_key
  deleteCarrier(condition: ModelCarrierConditionInput, input: DeleteCarrierInput!): Carrier @aws_api_key @aws_cognito_user_pools
  deleteCarriersStoreConfig(condition: ModelCarriersStoreConfigConditionInput, input: DeleteCarriersStoreConfigInput!): CarriersStoreConfig @aws_api_key @aws_cognito_user_pools
  deleteOrder(condition: ModelOrderConditionInput, input: DeleteOrderInput!): Order @aws_api_key @aws_cognito_user_pools
  deleteSalesChannel(condition: ModelSalesChannelConditionInput, input: DeleteSalesChannelInput!): SalesChannel @aws_api_key
  deleteSalesSource(condition: ModelSalesSourceConditionInput, input: DeleteSalesSourceInput!): SalesSource @aws_api_key
  deleteService(condition: ModelServiceConditionInput, input: DeleteServiceInput!): Service @aws_api_key @aws_cognito_user_pools
  deleteStoreConfig(condition: ModelStoreConfigConditionInput, input: DeleteStoreConfigInput!): StoreConfig @aws_api_key
  deleteTrackingTimeline(condition: ModelTrackingTimelineConditionInput, input: DeleteTrackingTimelineInput!): TrackingTimeline @aws_api_key @aws_cognito_user_pools
  deleteWorksheet(condition: ModelWorksheetConditionInput, input: DeleteWorksheetInput!): Worksheet @aws_api_key
  updateAccount(condition: ModelAccountConditionInput, input: UpdateAccountInput!): Account @aws_api_key
  updateBatch(condition: ModelBatchConditionInput, input: UpdateBatchInput!): Batch @aws_api_key
  updateCarrier(condition: ModelCarrierConditionInput, input: UpdateCarrierInput!): Carrier @aws_api_key @aws_cognito_user_pools
  updateCarriersStoreConfig(condition: ModelCarriersStoreConfigConditionInput, input: UpdateCarriersStoreConfigInput!): CarriersStoreConfig @aws_api_key @aws_cognito_user_pools
  updateOrder(condition: ModelOrderConditionInput, input: UpdateOrderInput!): Order @aws_api_key @aws_cognito_user_pools
  updateSalesChannel(condition: ModelSalesChannelConditionInput, input: UpdateSalesChannelInput!): SalesChannel @aws_api_key
  updateSalesSource(condition: ModelSalesSourceConditionInput, input: UpdateSalesSourceInput!): SalesSource @aws_api_key
  updateService(condition: ModelServiceConditionInput, input: UpdateServiceInput!): Service @aws_api_key @aws_cognito_user_pools
  updateStoreConfig(condition: ModelStoreConfigConditionInput, input: UpdateStoreConfigInput!): StoreConfig @aws_api_key
  updateTrackingTimeline(condition: ModelTrackingTimelineConditionInput, input: UpdateTrackingTimelineInput!): TrackingTimeline @aws_api_key @aws_cognito_user_pools
  updateWorksheet(condition: ModelWorksheetConditionInput, input: UpdateWorksheetInput!): Worksheet @aws_api_key
}

type Order @aws_api_key @aws_cognito_user_pools {
  batchOrdersId: ID
  billing: Billing
  createdAt: AWSDateTime!
  createdDate: String
  customer: Customer
  deliveryChannel: String
  deliveryDate: String
  finishedDate: String
  hostname: String!
  invoices: [Invoice]
  items: [Item]
  marketingData: MarketingData
  metaData: AWSJSON
  notes: [String]
  observations: [String]
  orderAssignment: [OrderAssignment]
  orderId: String!
  payment: [Payment]
  prepareDate: String
  salesSourceId: [String]
  shipping: Shipping
  shippingEstimatedDateMin: String
  status: String
  storeConfigId: [String]
  transactionDate: String
  updatedAt: AWSDateTime!
  vendor: Vendor
}

type OrderAssignment @aws_api_key @aws_cognito_user_pools {
  finishedDate: String
  initDate: String
  status: String
  worksheetId: String
}

type OrderSource @aws_api_key {
  orderId: String
  quantity: Float
}

type OrderStatsResponse {
  completedOrders: Int
  date: String
  pendingOrders: Int
  totalOrders: Int
}

type PackageService @aws_api_key @aws_cognito_user_pools {
  description: String
  dimensions: ServiceDimensionsPacking
  envelope: String
  id: ID!
  items: [ServiceItemsPackage]
  orderId: String!
  totalValue: Float
  weight: String
}

type Payment @aws_api_key @aws_cognito_user_pools {
  authorization: String
  baseTotal: Float
  cardNumber: String
  currency: Currrency
  date: String
  discount: Float
  firstDigits: String
  grandTotal: Float
  installments: String
  lastDigits: String
  method: PaymentMethod
  paymentHolder: String
  paymentId: String
  paymentName: String
  plcConversionRate: Float
  priceListCurrency: Currrency
  tax: Float
  transactionId: String
  transactionRef: String
}

type PickerAssignment @aws_api_key {
  assignmentDate: AWSDateTime
  method: AssignmentMethod
  pickerId: String
}

type Query {
  getAccount(id: ID!): Account @aws_api_key
  getBatch(id: ID!): Batch @aws_api_key
  getCarrier(id: ID!): Carrier @aws_api_key @aws_cognito_user_pools
  getCarriersStoreConfig(id: ID!): CarriersStoreConfig @aws_api_key @aws_cognito_user_pools
  getOrder(orderId: String!): Order @aws_api_key @aws_cognito_user_pools
  getSalesChannel(id: ID!): SalesChannel @aws_api_key
  getSalesSource(id: ID!): SalesSource @aws_api_key
  getService(id: ID!): Service @aws_api_key @aws_cognito_user_pools
  getStoreConfig(id: ID!): StoreConfig @aws_api_key
  getTrackingTimeline(id: ID!): TrackingTimeline @aws_api_key @aws_cognito_user_pools
  getWorksheet(id: ID!): Worksheet @aws_api_key
  listAccounts(filter: ModelAccountFilterInput, id: ID, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelAccountConnection @aws_api_key
  listBatches(filter: ModelBatchFilterInput, id: ID, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelBatchConnection @aws_api_key
  listCarriers(filter: ModelCarrierFilterInput, id: ID, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelCarrierConnection @aws_api_key @aws_cognito_user_pools
  listCarriersStoreConfigs(filter: ModelCarriersStoreConfigFilterInput, id: ID, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelCarriersStoreConfigConnection @aws_api_key @aws_cognito_user_pools
  listOrders(filter: ModelOrderFilterInput, limit: Int, nextToken: String, orderId: String, sortDirection: ModelSortDirection): ModelOrderConnection @aws_api_key @aws_cognito_user_pools
  listSalesChannels(filter: ModelSalesChannelFilterInput, id: ID, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelSalesChannelConnection @aws_api_key
  listSalesSources(filter: ModelSalesSourceFilterInput, limit: Int, nextToken: String): ModelSalesSourceConnection @aws_api_key
  listServices(filter: ModelServiceFilterInput, id: ID, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelServiceConnection @aws_api_key @aws_cognito_user_pools
  listStoreConfigs(filter: ModelStoreConfigFilterInput, id: ID, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelStoreConfigConnection @aws_api_key
  listTrackingTimelines(filter: ModelTrackingTimelineFilterInput, id: ID, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelTrackingTimelineConnection @aws_api_key @aws_cognito_user_pools
  listWorksheets(filter: ModelWorksheetFilterInput, id: ID, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelWorksheetConnection @aws_api_key
  searchOrders(filters: OrderFilters, pagination: OrderPagination): [Order]
  searchOrdersStats(filters: OrderFilters, timeZone: String): [OrderStatsResponse]
}

type Reason @aws_api_key @aws_cognito_user_pools {
  id: String
  name: String
}

type SalesChannel @aws_api_key {
  account: Account
  accountSalesChannelsId: ID
  createdAt: AWSDateTime!
  id: ID!
  name: String!
  salesSource(filter: ModelSalesSourceFilterInput, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelSalesSourceConnection
  type: AccountTypes
  updatedAt: AWSDateTime!
}

type SalesSource @aws_api_key {
  configuration: [CConfigurations]
  createdAt: AWSDateTime!
  downloadOrders: Boolean
  id: ID!
  salesChannel: SalesChannel!
  salesChannelSalesSourceId: ID
  salesSourceStoreConfigId: ID!
  storeConfig: StoreConfig!
  storeConfigSalesSourcesId: ID
  type: String
  updatedAt: AWSDateTime!
  warehouseId: String!
  warehouseName: String!
}

type Schedule @aws_api_key @aws_cognito_user_pools {
  fromDate: String
  toDate: String
}

type Service @aws_api_key @aws_cognito_user_pools {
  agent: ServiceAgent
  carrierId: String!
  carrierLogo: String
  carrierName: String!
  carrierServiceType: CarrierType
  comments: String
  createdAt: AWSDateTime!
  evidences: [ServiceEvidence]
  id: ID!
  labels: [ServiceLabel]
  metaData: AWSJSON
  notes: [ServiceNotes]
  orderId: String!
  packages: [PackageService]
  paymentMethod: ServicePaymentMethod
  rating: Float
  receiver: ServiceReceiver!
  seller: String!
  sender: ServiceSender!
  serviceId: String
  shippingEstimatedDate: AWSDateTime
  shippingPrice: Float
  status: ServiceStatus!
  timeline(filter: ModelTrackingTimelineFilterInput, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelTrackingTimelineConnection
  timezone: CTimezone!
  totalDistanceTraveled: Int
  trackingUrl: String
  type: ServiceType!
  updatedAt: AWSDateTime!
}

type ServiceAgent @aws_api_key @aws_cognito_user_pools {
  email: String
  id: String!
  identification: String
  name: String!
  phone: String
  vehicle: ServiceVehicle
}

type ServiceDeliveryWindow @aws_api_key @aws_cognito_user_pools {
  finalDate: AWSDateTime
  initialDate: AWSDateTime
  name: String
}

type ServiceDimensionsPacking @aws_api_key @aws_cognito_user_pools {
  height: String
  length: String
  width: String
}

type ServiceEvidence @aws_api_key @aws_cognito_user_pools {
  author: String
  content: String!
  date: AWSDateTime!
  type: ServiceEvidenceType!
}

type ServiceItemsPackage @aws_api_key @aws_cognito_user_pools {
  ean: String!
  id: ID!
  image: String
  name: String!
  price: Float!
  quantity: Int!
  refId: String
  type: String
  weight: String
}

type ServiceLabel @aws_api_key @aws_cognito_user_pools {
  id: ID!
  name: String!
  type: ServiceLabelType!
  url: String!
}

type ServiceNotes @aws_api_key @aws_cognito_user_pools {
  author: String
  content: String!
  date: AWSDateTime!
  type: ServiceNotesType!
}

type ServiceReceiver @aws_api_key @aws_cognito_user_pools {
  address: String
  addressComplement: String
  city: String
  contactName: String
  country: String
  deliveryDate: AWSDateTime!
  deliveryWindow: ServiceDeliveryWindow
  email: String
  identification: String
  location: CLocation
  name: String
  phone: String
  state: String
  zipCode: String
}

type ServiceSender @aws_api_key @aws_cognito_user_pools {
  address: String
  addressComplement: String
  city: String
  country: String
  deliveryWindow: ServiceDeliveryWindow
  email: String
  location: CLocation
  name: String
  phone: String
  pickupDate: AWSDateTime!
  state: String
  zipCode: String
}

type ServiceTimeline {
  date: AWSDateTime!
  status: ServiceStatus!
}

type Shipping @aws_api_key @aws_cognito_user_pools {
  orderUniqueAddress: Boolean
  shippingInfo: [ShippingInfo]
  tracking: [Tracking]
}

type ShippingInfo @aws_api_key @aws_cognito_user_pools {
  address1: String
  address2: String
  carrier: ShippingInfoCarrier
  city: String
  contactName: String
  contactPhone: String
  country: String
  indications: String
  itemId: String
  location: Location
  schedule: Schedule
  shippingMethod: ShippingMethod
  shippingType: ShippingType
  state: String
}

type ShippingInfoCarrier @aws_api_key @aws_cognito_user_pools {
  id: String
  name: String
  phone: String
  type: String
}

type ShippingMethod @aws_api_key @aws_cognito_user_pools {
  id: String
  name: String
  saleChannelShippingInfo: AWSJSON
  subTotal: Float
  taxes: Float
  total: Float
}

type StoreConfig @aws_api_key {
  batchInterval: Int
  capacityManagement: Int
  createdAt: AWSDateTime!
  general: GeneralConfig
  globalOrders: Int
  id: ID!
  isActive: Boolean
  localOrders: Int
  packages: [AvailablePackages]
  packingPath: String
  preparationTime: Int
  salesSources(filter: ModelSalesSourceFilterInput, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelSalesSourceConnection
  timezone: CTimezone
  updatedAt: AWSDateTime!
}

type StoreLocation @aws_api_key {
  latitude: Float
  longitude: Float
}

type Subscription {
  onCreateAccount: Account @aws_api_key @aws_subscribe(mutations : ["createAccount"])
  onCreateBatch: Batch @aws_api_key @aws_subscribe(mutations : ["createBatch"])
  onCreateCarrier: Carrier @aws_api_key @aws_cognito_user_pools @aws_subscribe(mutations : ["createCarrier"])
  onCreateCarriersStoreConfig: CarriersStoreConfig @aws_api_key @aws_cognito_user_pools @aws_subscribe(mutations : ["createCarriersStoreConfig"])
  onCreateOrder: Order @aws_api_key @aws_cognito_user_pools @aws_subscribe(mutations : ["createOrder"])
  onCreateSalesChannel: SalesChannel @aws_api_key @aws_subscribe(mutations : ["createSalesChannel"])
  onCreateSalesSource: SalesSource @aws_api_key @aws_subscribe(mutations : ["createSalesSource"])
  onCreateService: Service @aws_api_key @aws_cognito_user_pools @aws_subscribe(mutations : ["createService"])
  onCreateStoreConfig: StoreConfig @aws_api_key @aws_subscribe(mutations : ["createStoreConfig"])
  onCreateTrackingTimeline: TrackingTimeline @aws_api_key @aws_cognito_user_pools @aws_subscribe(mutations : ["createTrackingTimeline"])
  onCreateWorksheet: Worksheet @aws_api_key @aws_subscribe(mutations : ["createWorksheet"])
  onDeleteAccount: Account @aws_api_key @aws_subscribe(mutations : ["deleteAccount"])
  onDeleteBatch: Batch @aws_api_key @aws_subscribe(mutations : ["deleteBatch"])
  onDeleteCarrier: Carrier @aws_api_key @aws_cognito_user_pools @aws_subscribe(mutations : ["deleteCarrier"])
  onDeleteCarriersStoreConfig: CarriersStoreConfig @aws_api_key @aws_cognito_user_pools @aws_subscribe(mutations : ["deleteCarriersStoreConfig"])
  onDeleteOrder: Order @aws_api_key @aws_cognito_user_pools @aws_subscribe(mutations : ["deleteOrder"])
  onDeleteSalesChannel: SalesChannel @aws_api_key @aws_subscribe(mutations : ["deleteSalesChannel"])
  onDeleteSalesSource: SalesSource @aws_api_key @aws_subscribe(mutations : ["deleteSalesSource"])
  onDeleteService: Service @aws_api_key @aws_cognito_user_pools @aws_subscribe(mutations : ["deleteService"])
  onDeleteStoreConfig: StoreConfig @aws_api_key @aws_subscribe(mutations : ["deleteStoreConfig"])
  onDeleteTrackingTimeline: TrackingTimeline @aws_api_key @aws_cognito_user_pools @aws_subscribe(mutations : ["deleteTrackingTimeline"])
  onDeleteWorksheet: Worksheet @aws_api_key @aws_subscribe(mutations : ["deleteWorksheet"])
  onUpdateAccount: Account @aws_api_key @aws_subscribe(mutations : ["updateAccount"])
  onUpdateBatch: Batch @aws_api_key @aws_subscribe(mutations : ["updateBatch"])
  onUpdateCarrier: Carrier @aws_api_key @aws_cognito_user_pools @aws_subscribe(mutations : ["updateCarrier"])
  onUpdateCarriersStoreConfig: CarriersStoreConfig @aws_api_key @aws_cognito_user_pools @aws_subscribe(mutations : ["updateCarriersStoreConfig"])
  onUpdateOrder: Order @aws_api_key @aws_cognito_user_pools @aws_subscribe(mutations : ["updateOrder"])
  onUpdateSalesChannel: SalesChannel @aws_api_key @aws_subscribe(mutations : ["updateSalesChannel"])
  onUpdateSalesSource: SalesSource @aws_api_key @aws_subscribe(mutations : ["updateSalesSource"])
  onUpdateService: Service @aws_api_key @aws_cognito_user_pools @aws_subscribe(mutations : ["updateService"])
  onUpdateStoreConfig: StoreConfig @aws_api_key @aws_subscribe(mutations : ["updateStoreConfig"])
  onUpdateTrackingTimeline: TrackingTimeline @aws_api_key @aws_cognito_user_pools @aws_subscribe(mutations : ["updateTrackingTimeline"])
  onUpdateWorksheet: Worksheet @aws_api_key @aws_subscribe(mutations : ["updateWorksheet"])
}

type Taxonomy @aws_api_key @aws_cognito_user_pools {
  children: [Taxonomy]
  id: String
  name: String
}

type Tracking @aws_api_key @aws_cognito_user_pools {
  carrier: String
  createDate: String
  delivered: Boolean
  deliveredDate: String
  id: String
  packages: [String]
  trackingKey: String
  trackingUrl: String
}

type TrackingTimeline @aws_api_key @aws_cognito_user_pools {
  author: String
  createdAt: AWSDateTime!
  date: AWSDateTime!
  description: String
  id: ID!
  metaData: AWSJSON
  serviceID: ID!
  type: TrackingTimelineType!
  updatedAt: AWSDateTime!
}

type Vendor @aws_api_key @aws_cognito_user_pools {
  name: String
  vendorId: String
}

type Worksheet @aws_api_key {
  batchWorksheetsId: ID
  categoriesIds: [String]
  createdAt: AWSDateTime
  finishedDate: AWSDateTime
  id: ID!
  items: [ItemsByWorksheet]
  ordersIds: [String!]
  pickerAssignment: PickerAssignment
  status: WorksheetStatus
  totalItems: Int
  updatedAt: AWSDateTime!
}

enum AccountTypes {
  CALL_CENTER
  ECOMMERCE
  MARKETPLACE
  MOBILE_APP
  OFFLINE
  POS
}

enum AssignmentMethod {
  AUTOMATIC
  MANUAL
}

enum CEnvironment {
  DEV
  PROD
}

enum CarrierFormConfigurationAuthType {
  HEADER
  QUERY_STRING
}

enum CarrierFormConfigurationFieldType {
  CHECKBOX
  NUMBER
  PASSWORD
  RADIO
  SELECT
  TEXT
}

enum CarrierIntegrationMethod {
  GET
  PATCH
  POST
  PUT
}

enum CarrierIntegrationProtocol {
  HTTP
  HTTPS
}

enum CarrierPricingType {
  FREE
  MONTHLY_FEE
  TRANSACTIONS_FEE
}

enum CarrierShippingPaymentMethod {
  CASH_ON_DELIVERY
  CREDIT
  PIN_PAD
}

enum CarrierType {
  EXPRESS
  INTERNATIONAL
  NATIONAL
  OTHERS
  SPECIALIZED
}

enum DocType {
  POS
  WIDE
}

enum ItemsByWorksheetStatus {
  PENDING
  PICKED
  REJECTED
}

enum ModelAttributeTypes {
  _null
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
}

enum ModelSortDirection {
  ASC
  DESC
}

enum NotFoundOptions {
  REFUND
  REPLACE
  SUGGEST
}

enum PaymentMethod {
  CASH
  CASH_ON_DELIVERY
  COUPON
  CREDIT
  DEBIT
  GIFT_CARD
}

enum ServiceEvidenceType {
  IMAGE
  TEXT
}

enum ServiceLabelType {
  BASE64
  PDF
  TEXT
  ZPL
}

enum ServiceNotesType {
  COMMENT
  ERROR
}

enum ServicePaymentMethod {
  CASH_ON_DELIVERY
  ONLINE
  PIN_PAD
}

enum ServiceStatus {
  ASSIGNED
  CANCELED
  CREATED
  DELIVERED
  INCIDENT
  ON_HOLD
  ON_ROUTE
  PENDING
  PICKED
  RETURNED
}

enum ServiceType {
  DELIVERY
  PICKUP
  PICKUP_DELIVERY
  RETURN
}

enum ServiceVehicle {
  BIKE
  CAR
  DRONE
  SCOOTER
  TRUCK
  VAN
  WALK
}

enum ShippingType {
  DRIVE_THRU
  PICKUP_IN_STORE
  SHIPPING_TO_CUSTOMER
}

enum Temperature {
  AMBIENT
  COLD
  FROZEN
}

enum TrackingTimelineType {
  EVIDENCE
  LABEL
  NOTE
  OTHER
  STATUS
}

enum UnitOfMeasure {
  GRAMS
  KILOGRAMS
  POUNDS
  UNITS
}

enum WorksheetStatus {
  CANCELLED
  COMPLETED
  IN_PROGRESS
  PAUSED
  PENDING
}

input AssignmentTimeInput {
  assignedAt: String
}

input AvailablePackagesInput {
  description: String
  id: String!
  name: String!
  price: String!
  quantity: Int!
  type: String!
}

input BillingInput {
  address1: String
  address2: String
  billingName: String
  city: String
  country: String
  discount: Float
  docType: DocType
  freighAmount: Float
  id: String
  state: String
  tax: Float
  total: Float
}

input CConfigurationsInput {
  key: String
}

input CLocationInput {
  latitude: Float
  longitude: Float
}

input CTimezoneInput {
  offset: Float!
  value: String!
}

input CarrierFormConfigurationAuthInput {
  key: String!
  type: CarrierFormConfigurationAuthType!
  value: String!
}

input CarrierFormConfigurationFieldInput {
  description: String
  key: String!
  label: String!
  max: String
  min: String
  options: [CarrierFormConfigurationFieldOptionInput]
  priority: Int
  required: Boolean!
  type: CarrierFormConfigurationFieldType!
  value: String
}

input CarrierFormConfigurationFieldOptionInput {
  id: String!
  label: String!
  value: String!
}

input CarrierIntegrationEndpointInput {
  method: CarrierIntegrationMethod!
  protocol: CarrierIntegrationProtocol!
  url: String!
  variables: [CarrierFormConfigurationAuthInput]
}

input CarrierIntegrationEndpointsInput {
  cancelEndpoint: CarrierIntegrationEndpointInput
  endpoint: CarrierIntegrationEndpointInput!
  pauseEndpoint: CarrierIntegrationEndpointInput
  webhookEndpoint: String
}

input CarrierIntegrationInput {
  dev: CarrierIntegrationEndpointsInput
  prod: CarrierIntegrationEndpointsInput
}

input CarrierPricingInput {
  type: CarrierPricingType
  value: Float
}

input CarrierStoreConfigSettingsInput {
  key: String!
  label: String
  value: String
}

input ContactInformationInput {
  email: String
  name: String
  phone: String
}

input CreateAccountInput {
  activeAccount: Boolean
  actualOrders: Int
  configuration: [CConfigurationsInput]
  id: ID
  isVtexAccount: Boolean
  maxiumMonthlyOrders: Int
  name: String!
}

input CreateBatchInput {
  assignmentMethod: String
  assignmentTime: AssignmentTimeInput
  deliveryWindow: DeliveryWindowBatchInput
  id: ID
  seller: String
  status: String
}

input CreateCarrierInput {
  active: Boolean!
  agencyId: String!
  allocationTime: Int
  authorized: Boolean!
  cancelable: Boolean!
  countries: [String!]!
  formConfiguration: [CarrierFormConfigurationFieldInput!]!
  hasDevEnvironment: Boolean!
  id: ID
  integration: CarrierIntegrationInput!
  logo: String
  name: String!
  onHoldServices: Boolean!
  pricing: CarrierPricingInput
  shippingPaymentMethods: [CarrierShippingPaymentMethod]
  type: [CarrierType!]!
  withQueues: Boolean
}

input CreateCarriersStoreConfigInput {
  account: String!
  active: Boolean!
  carrierId: ID!
  config: [CarrierStoreConfigSettingsInput]
  deliveryMethod: [DeliveryMethodInput]
  env: CEnvironment!
  id: ID
  name: String
}

input CreateOrderInput {
  batchOrdersId: ID
  billing: BillingInput
  createdDate: String
  customer: CustomerInput
  deliveryChannel: String
  deliveryDate: String
  finishedDate: String
  hostname: String!
  invoices: [InvoiceInput]
  items: [ItemInput]
  marketingData: MarketingDataInput
  metaData: AWSJSON
  notes: [String]
  observations: [String]
  orderAssignment: [OrderAssignmentInput]
  orderId: String!
  payment: [PaymentInput]
  prepareDate: String
  salesSourceId: [String]
  shipping: ShippingInput
  shippingEstimatedDateMin: String
  status: String
  storeConfigId: [String]
  transactionDate: String
  vendor: VendorInput
}

input CreateSalesChannelInput {
  accountSalesChannelsId: ID
  id: ID
  name: String!
  type: AccountTypes
}

input CreateSalesSourceInput {
  configuration: [CConfigurationsInput]
  downloadOrders: Boolean
  id: ID
  salesChannelSalesSourceId: ID
  salesSourceStoreConfigId: ID!
  storeConfigSalesSourcesId: ID
  type: String
  warehouseId: String!
  warehouseName: String!
}

input CreateServiceInput {
  agent: ServiceAgentInput
  carrierId: String!
  carrierLogo: String
  carrierName: String!
  carrierServiceType: CarrierType
  comments: String
  evidences: [ServiceEvidenceInput]
  id: ID
  labels: [ServiceLabelInput]
  metaData: AWSJSON
  notes: [ServiceNotesInput]
  orderId: String!
  packages: [PackageServiceInput]
  paymentMethod: ServicePaymentMethod
  rating: Float
  receiver: ServiceReceiverInput!
  seller: String!
  sender: ServiceSenderInput!
  serviceId: String
  shippingEstimatedDate: AWSDateTime
  shippingPrice: Float
  status: ServiceStatus!
  timezone: CTimezoneInput!
  totalDistanceTraveled: Int
  trackingUrl: String
  type: ServiceType!
}

input CreateStoreConfigInput {
  batchInterval: Int
  capacityManagement: Int
  general: GeneralConfigInput
  globalOrders: Int
  id: ID
  isActive: Boolean
  localOrders: Int
  packages: [AvailablePackagesInput]
  packingPath: String
  preparationTime: Int
  timezone: CTimezoneInput
}

input CreateTrackingTimelineInput {
  author: String
  date: AWSDateTime!
  description: String
  id: ID
  metaData: AWSJSON
  serviceID: ID!
  type: TrackingTimelineType!
}

input CreateWorksheetInput {
  batchWorksheetsId: ID
  categoriesIds: [String]
  createdAt: AWSDateTime
  finishedDate: AWSDateTime
  id: ID
  items: [ItemsByWorksheetInput]
  ordersIds: [String!]
  pickerAssignment: PickerAssignmentInput
  status: WorksheetStatus
  totalItems: Int
}

input CurrrencyInput {
  code: String
  decimalSeparator: String
  deicmalDigits: Int
  groupSeparator: String
  groupSize: Int
  name: String
  symbol: String
}

input CustomerInput {
  document: String
  documentType: String
  email: String
  firstName: String
  lastName: String
  level: String
  phone: String
  profileId: String
}

input DeleteAccountInput {
  id: ID!
}

input DeleteBatchInput {
  id: ID!
}

input DeleteCarrierInput {
  id: ID!
}

input DeleteCarriersStoreConfigInput {
  id: ID!
}

input DeleteOrderInput {
  orderId: String!
}

input DeleteSalesChannelInput {
  id: ID!
}

input DeleteSalesSourceInput {
  id: ID!
}

input DeleteServiceInput {
  id: ID!
}

input DeleteStoreConfigInput {
  id: ID!
}

input DeleteTrackingTimelineInput {
  id: ID!
}

input DeleteWorksheetInput {
  id: ID!
}

input DeliveryMethodInput {
  id: String
  name: String
  serviceType: CarrierType!
}

input DeliveryWindowBatchInput {
  finalHour: String
  initialHour: String
}

input DeliveryWindowInput {
  finalHour: String
  initialHour: String
  name: String
  weekDay: Int
}

input DimensionsInput {
  cubicWeight: Float
  height: Float
  lenght: Float
  weight: Float
  width: Float
}

input GeneralConfigInput {
  address: String
  addressComplement: String
  changePricesReasons: [ReasonInput]
  city: String
  contactInformation: ContactInformationInput
  country: String
  deliveryWindow: [DeliveryWindowInput]
  location: StoreLocationInput
  measurementUnit: String
  name: String
  replacementReasons: [ReasonInput]
  state: String
}

input InventoryDataInput {
  quantity: Float
  warehouseId: String
  warehouseName: String
}

input InvoiceInput {
  invoiceCreationDate: String
  invoiceKey: String
  invoiceNumber: String
  invoiceReceiptDate: String
  invoiceSubtotal: Float
  invoiceTaxes: Float
  invoiceTotal: Float
  invoiceUrl: String
  packages: [String]
}

input ItemAssignmentInput {
  AssignedAt: AWSDateTime
  FinishedAt: AWSDateTime
  StartPickingAt: AWSDateTime
}

input ItemInput {
  EAN: String
  additionalEAN: [String]
  additionalReferenceCode: [String]
  additionalSku: [String]
  basePrice: Float
  brand: TaxonomyInput
  categories: [TaxonomyInput]
  description: String
  dimensions: DimensionsInput
  id: String
  images: [String]
  inventoryData: InventoryDataInput
  isCombo: Boolean
  isTaxable: Boolean
  itemName: String
  label: String
  metaData: AWSJSON
  notes: [String]
  observations: [String]
  pickingOptions: ItemPickingOptionsInput
  price: Float
  qrCodeContent: String
  quantity: Float
  referenceCode: String
  sku: String
  storeConfig: String
  tax: Float
  temperature: Temperature
  unitMultiplier: Float
  unitOfMeasure: UnitOfMeasure
  weightableProduct: Boolean
}

input ItemPickingOptionsInput {
  alternateOptions: [String]
  onNotFound: NotFoundOptions
}

input ItemsByWorksheetInput {
  ID: String
  categoriesId: String
  finalPrice: Float
  itemAssignment: ItemAssignmentInput
  name: String
  orderSource: [OrderSourceInput]
  originalPrice: Float
  status: ItemsByWorksheetStatus
  temperature: String
  totalQuantity: Int
}

input LocationInput {
  alt: Float
  lat: Float
  lng: Float
}

input MarketingDataInput {
  id: String
  marketingTags: [String]
  utmCampaign: String
  utmMedium: String
  utmPartner: String
  utmSource: String
  utmiPart: String
  utmipage: String
}

input ModelAccountConditionInput {
  activeAccount: ModelBooleanInput
  actualOrders: ModelIntInput
  and: [ModelAccountConditionInput]
  isVtexAccount: ModelBooleanInput
  maxiumMonthlyOrders: ModelIntInput
  name: ModelStringInput
  not: ModelAccountConditionInput
  or: [ModelAccountConditionInput]
}

input ModelAccountFilterInput {
  activeAccount: ModelBooleanInput
  actualOrders: ModelIntInput
  and: [ModelAccountFilterInput]
  id: ModelIDInput
  isVtexAccount: ModelBooleanInput
  maxiumMonthlyOrders: ModelIntInput
  name: ModelStringInput
  not: ModelAccountFilterInput
  or: [ModelAccountFilterInput]
}

input ModelAccountTypesInput {
  eq: AccountTypes
  ne: AccountTypes
}

input ModelBatchConditionInput {
  and: [ModelBatchConditionInput]
  assignmentMethod: ModelStringInput
  not: ModelBatchConditionInput
  or: [ModelBatchConditionInput]
  seller: ModelStringInput
  status: ModelStringInput
}

input ModelBatchFilterInput {
  and: [ModelBatchFilterInput]
  assignmentMethod: ModelStringInput
  id: ModelIDInput
  not: ModelBatchFilterInput
  or: [ModelBatchFilterInput]
  seller: ModelStringInput
  status: ModelStringInput
}

input ModelBooleanInput {
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  eq: Boolean
  ne: Boolean
}

input ModelCEnvironmentInput {
  eq: CEnvironment
  ne: CEnvironment
}

input ModelCarrierConditionInput {
  active: ModelBooleanInput
  agencyId: ModelStringInput
  allocationTime: ModelIntInput
  and: [ModelCarrierConditionInput]
  authorized: ModelBooleanInput
  cancelable: ModelBooleanInput
  countries: ModelStringInput
  hasDevEnvironment: ModelBooleanInput
  logo: ModelStringInput
  name: ModelStringInput
  not: ModelCarrierConditionInput
  onHoldServices: ModelBooleanInput
  or: [ModelCarrierConditionInput]
  shippingPaymentMethods: ModelCarrierShippingPaymentMethodListInput
  type: ModelCarrierTypeInput
  withQueues: ModelBooleanInput
}

input ModelCarrierFilterInput {
  active: ModelBooleanInput
  agencyId: ModelStringInput
  allocationTime: ModelIntInput
  and: [ModelCarrierFilterInput]
  authorized: ModelBooleanInput
  cancelable: ModelBooleanInput
  countries: ModelStringInput
  hasDevEnvironment: ModelBooleanInput
  id: ModelIDInput
  logo: ModelStringInput
  name: ModelStringInput
  not: ModelCarrierFilterInput
  onHoldServices: ModelBooleanInput
  or: [ModelCarrierFilterInput]
  shippingPaymentMethods: ModelCarrierShippingPaymentMethodListInput
  type: ModelCarrierTypeInput
  withQueues: ModelBooleanInput
}

input ModelCarrierShippingPaymentMethodListInput {
  contains: CarrierShippingPaymentMethod
  eq: [CarrierShippingPaymentMethod]
  ne: [CarrierShippingPaymentMethod]
  notContains: CarrierShippingPaymentMethod
}

input ModelCarrierTypeInput {
  eq: CarrierType
  ne: CarrierType
}

input ModelCarriersStoreConfigConditionInput {
  account: ModelStringInput
  active: ModelBooleanInput
  and: [ModelCarriersStoreConfigConditionInput]
  carrierId: ModelIDInput
  env: ModelCEnvironmentInput
  name: ModelStringInput
  not: ModelCarriersStoreConfigConditionInput
  or: [ModelCarriersStoreConfigConditionInput]
}

input ModelCarriersStoreConfigFilterInput {
  account: ModelStringInput
  active: ModelBooleanInput
  and: [ModelCarriersStoreConfigFilterInput]
  carrierId: ModelIDInput
  env: ModelCEnvironmentInput
  id: ModelIDInput
  name: ModelStringInput
  not: ModelCarriersStoreConfigFilterInput
  or: [ModelCarriersStoreConfigFilterInput]
}

input ModelFloatInput {
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  between: [Float]
  eq: Float
  ge: Float
  gt: Float
  le: Float
  lt: Float
  ne: Float
}

input ModelIDInput {
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  beginsWith: ID
  between: [ID]
  contains: ID
  eq: ID
  ge: ID
  gt: ID
  le: ID
  lt: ID
  ne: ID
  notContains: ID
  size: ModelSizeInput
}

input ModelIntInput {
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  between: [Int]
  eq: Int
  ge: Int
  gt: Int
  le: Int
  lt: Int
  ne: Int
}

input ModelOrderConditionInput {
  and: [ModelOrderConditionInput]
  batchOrdersId: ModelIDInput
  createdDate: ModelStringInput
  deliveryChannel: ModelStringInput
  deliveryDate: ModelStringInput
  finishedDate: ModelStringInput
  hostname: ModelStringInput
  metaData: ModelStringInput
  not: ModelOrderConditionInput
  notes: ModelStringInput
  observations: ModelStringInput
  or: [ModelOrderConditionInput]
  prepareDate: ModelStringInput
  salesSourceId: ModelStringInput
  shippingEstimatedDateMin: ModelStringInput
  status: ModelStringInput
  storeConfigId: ModelStringInput
  transactionDate: ModelStringInput
}

input ModelOrderFilterInput {
  and: [ModelOrderFilterInput]
  batchOrdersId: ModelIDInput
  createdDate: ModelStringInput
  deliveryChannel: ModelStringInput
  deliveryDate: ModelStringInput
  finishedDate: ModelStringInput
  hostname: ModelStringInput
  metaData: ModelStringInput
  not: ModelOrderFilterInput
  notes: ModelStringInput
  observations: ModelStringInput
  or: [ModelOrderFilterInput]
  orderId: ModelStringInput
  prepareDate: ModelStringInput
  salesSourceId: ModelStringInput
  shippingEstimatedDateMin: ModelStringInput
  status: ModelStringInput
  storeConfigId: ModelStringInput
  transactionDate: ModelStringInput
}

input ModelSalesChannelConditionInput {
  accountSalesChannelsId: ModelIDInput
  and: [ModelSalesChannelConditionInput]
  name: ModelStringInput
  not: ModelSalesChannelConditionInput
  or: [ModelSalesChannelConditionInput]
  type: ModelAccountTypesInput
}

input ModelSalesChannelFilterInput {
  accountSalesChannelsId: ModelIDInput
  and: [ModelSalesChannelFilterInput]
  id: ModelIDInput
  name: ModelStringInput
  not: ModelSalesChannelFilterInput
  or: [ModelSalesChannelFilterInput]
  type: ModelAccountTypesInput
}

input ModelSalesSourceConditionInput {
  and: [ModelSalesSourceConditionInput]
  downloadOrders: ModelBooleanInput
  not: ModelSalesSourceConditionInput
  or: [ModelSalesSourceConditionInput]
  salesChannelSalesSourceId: ModelIDInput
  salesSourceStoreConfigId: ModelIDInput
  storeConfigSalesSourcesId: ModelIDInput
  type: ModelStringInput
  warehouseId: ModelStringInput
  warehouseName: ModelStringInput
}

input ModelSalesSourceFilterInput {
  and: [ModelSalesSourceFilterInput]
  downloadOrders: ModelBooleanInput
  id: ModelIDInput
  not: ModelSalesSourceFilterInput
  or: [ModelSalesSourceFilterInput]
  salesChannelSalesSourceId: ModelIDInput
  salesSourceStoreConfigId: ModelIDInput
  storeConfigSalesSourcesId: ModelIDInput
  type: ModelStringInput
  warehouseId: ModelStringInput
  warehouseName: ModelStringInput
}

input ModelServiceConditionInput {
  and: [ModelServiceConditionInput]
  carrierId: ModelStringInput
  carrierLogo: ModelStringInput
  carrierName: ModelStringInput
  carrierServiceType: ModelCarrierTypeInput
  comments: ModelStringInput
  metaData: ModelStringInput
  not: ModelServiceConditionInput
  or: [ModelServiceConditionInput]
  orderId: ModelStringInput
  paymentMethod: ModelServicePaymentMethodInput
  rating: ModelFloatInput
  seller: ModelStringInput
  serviceId: ModelStringInput
  shippingEstimatedDate: ModelStringInput
  shippingPrice: ModelFloatInput
  status: ModelServiceStatusInput
  totalDistanceTraveled: ModelIntInput
  trackingUrl: ModelStringInput
  type: ModelServiceTypeInput
}

input ModelServiceFilterInput {
  and: [ModelServiceFilterInput]
  carrierId: ModelStringInput
  carrierLogo: ModelStringInput
  carrierName: ModelStringInput
  carrierServiceType: ModelCarrierTypeInput
  comments: ModelStringInput
  id: ModelIDInput
  metaData: ModelStringInput
  not: ModelServiceFilterInput
  or: [ModelServiceFilterInput]
  orderId: ModelStringInput
  paymentMethod: ModelServicePaymentMethodInput
  rating: ModelFloatInput
  seller: ModelStringInput
  serviceId: ModelStringInput
  shippingEstimatedDate: ModelStringInput
  shippingPrice: ModelFloatInput
  status: ModelServiceStatusInput
  totalDistanceTraveled: ModelIntInput
  trackingUrl: ModelStringInput
  type: ModelServiceTypeInput
}

input ModelServicePaymentMethodInput {
  eq: ServicePaymentMethod
  ne: ServicePaymentMethod
}

input ModelServiceStatusInput {
  eq: ServiceStatus
  ne: ServiceStatus
}

input ModelServiceTypeInput {
  eq: ServiceType
  ne: ServiceType
}

input ModelSizeInput {
  between: [Int]
  eq: Int
  ge: Int
  gt: Int
  le: Int
  lt: Int
  ne: Int
}

input ModelStoreConfigConditionInput {
  and: [ModelStoreConfigConditionInput]
  batchInterval: ModelIntInput
  capacityManagement: ModelIntInput
  globalOrders: ModelIntInput
  isActive: ModelBooleanInput
  localOrders: ModelIntInput
  not: ModelStoreConfigConditionInput
  or: [ModelStoreConfigConditionInput]
  packingPath: ModelStringInput
  preparationTime: ModelIntInput
}

input ModelStoreConfigFilterInput {
  and: [ModelStoreConfigFilterInput]
  batchInterval: ModelIntInput
  capacityManagement: ModelIntInput
  globalOrders: ModelIntInput
  id: ModelIDInput
  isActive: ModelBooleanInput
  localOrders: ModelIntInput
  not: ModelStoreConfigFilterInput
  or: [ModelStoreConfigFilterInput]
  packingPath: ModelStringInput
  preparationTime: ModelIntInput
}

input ModelStringInput {
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  beginsWith: String
  between: [String]
  contains: String
  eq: String
  ge: String
  gt: String
  le: String
  lt: String
  ne: String
  notContains: String
  size: ModelSizeInput
}

input ModelTrackingTimelineConditionInput {
  and: [ModelTrackingTimelineConditionInput]
  author: ModelStringInput
  date: ModelStringInput
  description: ModelStringInput
  metaData: ModelStringInput
  not: ModelTrackingTimelineConditionInput
  or: [ModelTrackingTimelineConditionInput]
  serviceID: ModelIDInput
  type: ModelTrackingTimelineTypeInput
}

input ModelTrackingTimelineFilterInput {
  and: [ModelTrackingTimelineFilterInput]
  author: ModelStringInput
  date: ModelStringInput
  description: ModelStringInput
  id: ModelIDInput
  metaData: ModelStringInput
  not: ModelTrackingTimelineFilterInput
  or: [ModelTrackingTimelineFilterInput]
  serviceID: ModelIDInput
  type: ModelTrackingTimelineTypeInput
}

input ModelTrackingTimelineTypeInput {
  eq: TrackingTimelineType
  ne: TrackingTimelineType
}

input ModelWorksheetConditionInput {
  and: [ModelWorksheetConditionInput]
  batchWorksheetsId: ModelIDInput
  categoriesIds: ModelStringInput
  createdAt: ModelStringInput
  finishedDate: ModelStringInput
  not: ModelWorksheetConditionInput
  or: [ModelWorksheetConditionInput]
  ordersIds: ModelStringInput
  status: ModelWorksheetStatusInput
  totalItems: ModelIntInput
}

input ModelWorksheetFilterInput {
  and: [ModelWorksheetFilterInput]
  batchWorksheetsId: ModelIDInput
  categoriesIds: ModelStringInput
  createdAt: ModelStringInput
  finishedDate: ModelStringInput
  id: ModelIDInput
  not: ModelWorksheetFilterInput
  or: [ModelWorksheetFilterInput]
  ordersIds: ModelStringInput
  status: ModelWorksheetStatusInput
  totalItems: ModelIntInput
}

input ModelWorksheetStatusInput {
  eq: WorksheetStatus
  ne: WorksheetStatus
}

input OrderAssignmentInput {
  finishedDate: String
  initDate: String
  status: String
  worksheetId: String
}

input OrderFilters {
  deliveryDate: TimeFilter
  status: String
  storeConfig: String!
}

input OrderPagination {
  from: Int
  size: Int
}

input OrderSourceInput {
  orderId: String
  quantity: Float
}

input PackageServiceInput {
  description: String
  dimensions: ServiceDimensionsPackingInput
  envelope: String
  id: ID
  items: [ServiceItemsPackageInput]
  orderId: String!
  totalValue: Float
  weight: String
}

input PaymentInput {
  authorization: String
  baseTotal: Float
  cardNumber: String
  currency: CurrrencyInput
  date: String
  discount: Float
  firstDigits: String
  grandTotal: Float
  installments: String
  lastDigits: String
  method: PaymentMethod
  paymentHolder: String
  paymentId: String
  paymentName: String
  plcConversionRate: Float
  priceListCurrency: CurrrencyInput
  tax: Float
  transactionId: String
  transactionRef: String
}

input PickerAssignmentInput {
  assignmentDate: AWSDateTime
  method: AssignmentMethod
  pickerId: String
}

input ReasonInput {
  id: String
  name: String
}

input ScheduleInput {
  fromDate: String
  toDate: String
}

input ServiceAgentInput {
  email: String
  id: String!
  identification: String
  name: String!
  phone: String
  vehicle: ServiceVehicle
}

input ServiceDeliveryWindowInput {
  finalDate: AWSDateTime
  initialDate: AWSDateTime
  name: String
}

input ServiceDimensionsPackingInput {
  height: String
  length: String
  width: String
}

input ServiceEvidenceInput {
  author: String
  content: String!
  date: AWSDateTime!
  type: ServiceEvidenceType!
}

input ServiceItemsPackageInput {
  ean: String!
  id: ID
  image: String
  name: String!
  price: Float!
  quantity: Int!
  refId: String
  type: String
  weight: String
}

input ServiceLabelInput {
  id: ID
  name: String!
  type: ServiceLabelType!
  url: String!
}

input ServiceNotesInput {
  author: String
  content: String!
  date: AWSDateTime!
  type: ServiceNotesType!
}

input ServiceReceiverInput {
  address: String
  addressComplement: String
  city: String
  contactName: String
  country: String
  deliveryDate: AWSDateTime!
  deliveryWindow: ServiceDeliveryWindowInput
  email: String
  identification: String
  location: CLocationInput
  name: String
  phone: String
  state: String
  zipCode: String
}

input ServiceSenderInput {
  address: String
  addressComplement: String
  city: String
  country: String
  deliveryWindow: ServiceDeliveryWindowInput
  email: String
  location: CLocationInput
  name: String
  phone: String
  pickupDate: AWSDateTime!
  state: String
  zipCode: String
}

input ShippingInfoCarrierInput {
  id: String
  name: String
  phone: String
  type: String
}

input ShippingInfoInput {
  address1: String
  address2: String
  carrier: ShippingInfoCarrierInput
  city: String
  contactName: String
  contactPhone: String
  country: String
  indications: String
  itemId: String
  location: LocationInput
  schedule: ScheduleInput
  shippingMethod: ShippingMethodInput
  shippingType: ShippingType
  state: String
}

input ShippingInput {
  orderUniqueAddress: Boolean
  shippingInfo: [ShippingInfoInput]
  tracking: [TrackingInput]
}

input ShippingMethodInput {
  id: String
  name: String
  saleChannelShippingInfo: AWSJSON
  subTotal: Float
  taxes: Float
  total: Float
}

input StoreLocationInput {
  latitude: Float
  longitude: Float
}

input TaxonomyInput {
  children: [TaxonomyInput]
  id: String
  name: String
}

input TimeFilter {
  from: String
  to: String
}

input TrackingInput {
  carrier: String
  createDate: String
  delivered: Boolean
  deliveredDate: String
  id: String
  packages: [String]
  trackingKey: String
  trackingUrl: String
}

input UpdateAccountInput {
  activeAccount: Boolean
  actualOrders: Int
  configuration: [CConfigurationsInput]
  id: ID!
  isVtexAccount: Boolean
  maxiumMonthlyOrders: Int
  name: String
}

input UpdateBatchInput {
  assignmentMethod: String
  assignmentTime: AssignmentTimeInput
  deliveryWindow: DeliveryWindowBatchInput
  id: ID!
  seller: String
  status: String
}

input UpdateCarrierInput {
  active: Boolean
  agencyId: String
  allocationTime: Int
  authorized: Boolean
  cancelable: Boolean
  countries: [String!]
  formConfiguration: [CarrierFormConfigurationFieldInput!]
  hasDevEnvironment: Boolean
  id: ID!
  integration: CarrierIntegrationInput
  logo: String
  name: String
  onHoldServices: Boolean
  pricing: CarrierPricingInput
  shippingPaymentMethods: [CarrierShippingPaymentMethod]
  type: [CarrierType!]
  withQueues: Boolean
}

input UpdateCarriersStoreConfigInput {
  account: String
  active: Boolean
  carrierId: ID
  config: [CarrierStoreConfigSettingsInput]
  deliveryMethod: [DeliveryMethodInput]
  env: CEnvironment
  id: ID!
  name: String
}

input UpdateOrderInput {
  batchOrdersId: ID
  billing: BillingInput
  createdDate: String
  customer: CustomerInput
  deliveryChannel: String
  deliveryDate: String
  finishedDate: String
  hostname: String
  invoices: [InvoiceInput]
  items: [ItemInput]
  marketingData: MarketingDataInput
  metaData: AWSJSON
  notes: [String]
  observations: [String]
  orderAssignment: [OrderAssignmentInput]
  orderId: String!
  payment: [PaymentInput]
  prepareDate: String
  salesSourceId: [String]
  shipping: ShippingInput
  shippingEstimatedDateMin: String
  status: String
  storeConfigId: [String]
  transactionDate: String
  vendor: VendorInput
}

input UpdateSalesChannelInput {
  accountSalesChannelsId: ID
  id: ID!
  name: String
  type: AccountTypes
}

input UpdateSalesSourceInput {
  configuration: [CConfigurationsInput]
  downloadOrders: Boolean
  id: ID!
  salesChannelSalesSourceId: ID
  salesSourceStoreConfigId: ID
  storeConfigSalesSourcesId: ID
  type: String
  warehouseId: String
  warehouseName: String
}

input UpdateServiceInput {
  agent: ServiceAgentInput
  carrierId: String
  carrierLogo: String
  carrierName: String
  carrierServiceType: CarrierType
  comments: String
  evidences: [ServiceEvidenceInput]
  id: ID!
  labels: [ServiceLabelInput]
  metaData: AWSJSON
  notes: [ServiceNotesInput]
  orderId: String
  packages: [PackageServiceInput]
  paymentMethod: ServicePaymentMethod
  rating: Float
  receiver: ServiceReceiverInput
  seller: String
  sender: ServiceSenderInput
  serviceId: String
  shippingEstimatedDate: AWSDateTime
  shippingPrice: Float
  status: ServiceStatus
  timezone: CTimezoneInput
  totalDistanceTraveled: Int
  trackingUrl: String
  type: ServiceType
}

input UpdateStoreConfigInput {
  batchInterval: Int
  capacityManagement: Int
  general: GeneralConfigInput
  globalOrders: Int
  id: ID!
  isActive: Boolean
  localOrders: Int
  packages: [AvailablePackagesInput]
  packingPath: String
  preparationTime: Int
  timezone: CTimezoneInput
}

input UpdateTrackingTimelineInput {
  author: String
  date: AWSDateTime
  description: String
  id: ID!
  metaData: AWSJSON
  serviceID: ID
  type: TrackingTimelineType
}

input UpdateWorksheetInput {
  batchWorksheetsId: ID
  categoriesIds: [String]
  createdAt: AWSDateTime
  finishedDate: AWSDateTime
  id: ID!
  items: [ItemsByWorksheetInput]
  ordersIds: [String!]
  pickerAssignment: PickerAssignmentInput
  status: WorksheetStatus
  totalItems: Int
}

input VendorInput {
  name: String
  vendorId: String
}
